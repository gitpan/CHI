<html><head><title>CHI</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://search.cpan.org/s/style.css">

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.15,
  using Pod::Simple::PullParser v3.15,
  under Perl v5.012002 at Wed Mar  2 00:52:11 2011 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#FEATURES'>FEATURES</a>
  <li class='indexItem indexItem1'><a href='#CONSTRUCTOR'>CONSTRUCTOR</a>
  <li class='indexItem indexItem1'><a href='#INSTANCE_METHODS'>INSTANCE METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Getting_and_setting'>Getting and setting</a>
    <li class='indexItem indexItem2'><a href='#Removing_and_expiring'>Removing and expiring</a>
    <li class='indexItem indexItem2'><a href='#Inspecting_keys'>Inspecting keys</a>
    <li class='indexItem indexItem2'><a href='#Namespace_operations'>Namespace operations</a>
    <li class='indexItem indexItem2'><a href='#Multiple_key%2Fvalue_operations'>Multiple key/value operations</a>
    <li class='indexItem indexItem2'><a href='#Property_accessors'>Property accessors</a>
    <li class='indexItem indexItem2'><a href='#Deprecated_methods'>Deprecated methods</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DURATION_EXPRESSIONS'>DURATION EXPRESSIONS</a>
  <li class='indexItem indexItem1'><a href='#KEY_AND_VALUE_TRANSFORMATIONS'>KEY AND VALUE TRANSFORMATIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Key_transformations'>Key transformations</a>
    <li class='indexItem indexItem2'><a href='#Value_transformations'>Value transformations</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SUBCACHES'>SUBCACHES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#L1_cache'>L1 cache</a>
    <li class='indexItem indexItem2'><a href='#Mirror_cache'>Mirror cache</a>
    <li class='indexItem indexItem2'><a href='#Creating_subcaches'>Creating subcaches</a>
    <li class='indexItem indexItem2'><a href='#Common_subcache_behaviors'>Common subcache behaviors</a>
    <li class='indexItem indexItem2'><a href='#Multiple_subcaches'>Multiple subcaches</a>
    <li class='indexItem indexItem2'><a href='#Methods_for_parent_caches'>Methods for parent caches</a>
    <li class='indexItem indexItem2'><a href='#Methods_for_subcaches'>Methods for subcaches</a>
    <li class='indexItem indexItem2'><a href='#Developing_new_kinds_of_subcaches'>Developing new kinds of subcaches</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SIZE_AWARENESS'>SIZE AWARENESS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Maximum_size_and_discard_policies'>Maximum size and discard policies</a>
    <li class='indexItem indexItem2'><a href='#Appropriate_drivers'>Appropriate drivers</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AVAILABILITY_OF_DRIVERS'>AVAILABILITY OF DRIVERS</a>
  <li class='indexItem indexItem1'><a href='#PERFORMANCE_COMPARISON_OF_DRIVERS'>PERFORMANCE COMPARISON OF DRIVERS</a>
  <li class='indexItem indexItem1'><a href='#DEVELOPING_NEW_DRIVERS'>DEVELOPING NEW DRIVERS</a>
  <li class='indexItem indexItem1'><a href='#LOGGING'>LOGGING</a>
  <li class='indexItem indexItem1'><a href='#STATS'>STATS</a>
  <li class='indexItem indexItem1'><a href='#RELATION_TO_OTHER_MODULES'>RELATION TO OTHER MODULES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Cache%3A%3ACache'>Cache::Cache</a>
    <li class='indexItem indexItem2'><a href='#Cache'>Cache</a>
    <li class='indexItem indexItem2'><a href='#Cache%3A%3AMemcached%2C_Cache%3A%3AFastMmap%2C_etc.'>Cache::Memcached, Cache::FastMmap, etc.</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SUPPORT_AND_DOCUMENTATION'>SUPPORT AND DOCUMENTATION</a>
  <li class='indexItem indexItem1'><a href='#TODO'>TODO</a>
  <li class='indexItem indexItem1'><a href='#ACKNOWLEDGMENTS'>ACKNOWLEDGMENTS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>CHI - Unified cache handling interface</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    use CHI;

    # Choose a standard driver
    #
    my $cache = CHI-&#62;new( driver =&#62; &#39;Memory&#39;, global =&#62; 1 );
    my $cache = CHI-&#62;new( driver =&#62; &#39;RawMemory&#39;, global =&#62; 1 );
    my $cache = CHI-&#62;new( driver =&#62; &#39;File&#39;,
        root_dir =&#62; &#39;/path/to/root&#39;
    );
    my $cache = CHI-&#62;new( driver =&#62; &#39;FastMmap&#39;,
        root_dir   =&#62; &#39;/path/to/root&#39;,
        cache_size =&#62; &#39;1k&#39;
    );
    my $cache = CHI-&#62;new( driver  =&#62; &#39;Memcached::libmemcached&#39;,
        servers =&#62; [ &#34;10.0.0.15:11211&#34;, &#34;10.0.0.15:11212&#34; ],
        l1_cache =&#62; { driver =&#62; &#39;FastMmap&#39;, root_dir =&#62; &#39;/path/to/root&#39; }
    );
    my $cache = CHI-&#62;new( driver =&#62; &#39;DBI&#39;,
        dbh =&#62; $dbh
    );
    my $cache = CHI-&#62;new( driver =&#62; &#39;BerkeleyDB&#39;,
        root_dir =&#62; &#39;/path/to/root&#39;
    );

    # Create your own driver
    # 
    my $cache = CHI-&#62;new( driver_class =&#62; &#39;My::Special::Driver&#39;, ... );

    # Cache operations
    #
    my $customer = $cache-&#62;get($name);
    if ( !defined $customer ) {
        $customer = get_customer_from_db($name);
        $cache-&#62;set( $name, $customer, &#34;10 minutes&#34; );
    }
    my $customer2 = $cache-&#62;compute($name2, &#34;10 minutes&#34;, sub {
        get_customer_from_db($name2)
    });
    $cache-&#62;remove($name);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>CHI provides a unified caching API, designed to assist a developer in persisting data for a specified period of time.</p>

<p>The CHI interface is implemented by driver classes that support fetching, storing and clearing of data. Driver classes exist or will exist for the gamut of storage backends available to Perl, such as memory, plain files, memory mapped files, memcached, and DBI.</p>

<p>CHI is intended as an evolution of DeWitt Clinton&#39;s <a href="http://search.cpan.org/perldoc?Cache%3A%3ACache" class="podlinkpod"
>Cache::Cache</a> package, adhering to the basic Cache API but adding new features and addressing limitations in the Cache::Cache implementation.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FEATURES"
>FEATURES</a></h1>

<ul>
<li>Easy to create new drivers</li>

<li>Uniform support for namespaces</li>

<li>Automatic serialization of keys and values</li>

<li>Multilevel caches</li>

<li>Probabilistic expiration and busy locks, to reduce cache miss stampedes</li>

<li>Optional logging and statistics collection of cache activity</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONSTRUCTOR"
>CONSTRUCTOR</a></h1>

<p>To create a new cache handle, call CHI-&#62;new. It takes the following common options. All are optional, except that either <i>driver</i> or <i>driver_class</i> must be passed.</p>

<dl>
<dt><a name="driver_[STRING]"
>driver [STRING]</a></dt>

<dd>
<p>The name of a standard driver to drive the cache, for example &#34;Memory&#34; or &#34;File&#34;. CHI will prefix the string with &#34;CHI::Driver::&#34;.</p>

<dt><a name="driver_class_[STRING]"
>driver_class [STRING]</a></dt>

<dd>
<p>The exact CHI::Driver subclass to drive the cache, for example &#34;My::Memory::Driver&#34;.</p>

<dt><a name="expires_in_[DURATION]"
>expires_in [DURATION]</a></dt>

<dd>
<dt><a name="expires_at_[INT]"
>expires_at [INT]</a></dt>

<dd>
<dt><a name="expires_variance_[FLOAT]"
>expires_variance [FLOAT]</a></dt>

<dd>
<p>Provide default values for the corresponding <a href="#set" class="podlinkpod"
>&#34;set&#34;</a> options.</p>

<dt><a name="key_digester_[STRING|HASHREF|OBJECT]"
>key_digester [STRING|HASHREF|OBJECT]</a></dt>

<dd>
<p>Digest algorithm to use on keys longer than <a href="#max_key_length" class="podlinkpod"
>&#34;max_key_length&#34;</a> - e.g. &#34;MD5&#34;, &#34;SHA-1&#34;, or &#34;SHA-256&#34;.</p>

<p>Can be a <a href="http://search.cpan.org/perldoc?Digest" class="podlinkpod"
>Digest</a> object, or a string or hashref which will passed to Digest-&#62;new(). You will need to ensure Digest is installed to use these options.</p>

<p>Default is &#34;MD5&#34;.</p>

<dt><a name="label_[STRING]"
>label [STRING]</a></dt>

<dd>
<p>A label for the cache as a whole, independent of namespace - e.g. &#34;web-file-cache&#34;. Used when referring to the cache in logs, statistics, and error messages. By default, set to <a href="#short_driver_name" class="podlinkpod"
>&#34;short_driver_name&#34;</a>.</p>

<dt><a name="l1_cache_[HASHREF]"
>l1_cache [HASHREF]</a></dt>

<dd>
<p>Add an L1 cache as a subcache. See <a href="#SUBCACHES" class="podlinkpod"
>&#34;SUBCACHES&#34;</a>.</p>

<dt><a name="max_key_length_[INT]"
>max_key_length [INT]</a></dt>

<dd>
<p>Keys over this size will be <a href="http://search.cpan.org/perldoc?key_digester" class="podlinkpod"
>digested</a>. The default is driver-specific; <a href="http://search.cpan.org/perldoc?File" class="podlinkpod"
>CHI::Driver::File</a>, for example, defaults this to 240 due to file system limits. For most drivers there is no maximum.</p>

<dt><a name="mirror_cache_[HASHREF]"
>mirror_cache [HASHREF]</a></dt>

<dd>
<p>Add an mirror cache as a subcache. See <a href="#SUBCACHES" class="podlinkpod"
>&#34;SUBCACHES&#34;</a>.</p>

<dt><a name="namespace_[STRING]"
>namespace [STRING]</a></dt>

<dd>
<p>Identifies a namespace that all cache entries for this object will be in. This allows easy separation of multiple, distinct caches without worrying about key collision.</p>

<p>Suggestions for easy namespace selection:</p>

<ul>
<li>In a class, use the class name:
<pre>    my $cache = CHI-&#62;new(namespace =&#62; __PACKAGE__, ...);</pre>
</li>

<li>In a script, use the script&#39;s absolute path name:
<pre>    use Cwd qw(realpath);
    my $cache = CHI-&#62;new(namespace =&#62; realpath($0), ...);</pre>
</li>

<li>In a web template, use the template name. For example, in Mason, $m-&#62;cache will set the namespace to the current component path.</li>
</ul>

<p>Defaults to &#39;Default&#39; if not specified.</p>

<dt><a name="serializer_[STRING|HASHREF|OBJECT]"
>serializer [STRING|HASHREF|OBJECT]</a></dt>

<dd>
<p>An object to use for serializing data before storing it in the cache, and deserializing data after retrieving it from the cache.</p>

<p>If this is a string, a <a href="http://search.cpan.org/perldoc?Data%3A%3ASerializer" class="podlinkpod"
>Data::Serializer</a> object will be created, with the string passed as the &#39;serializer&#39; option and raw=1. Common options include &#39;Storable&#39;, &#39;Data::Dumper&#39;, and &#39;YAML&#39;. If this is a hashref, <a href="http://search.cpan.org/perldoc?Data%3A%3ASerializer-%3Enew" class="podlinkpod"
>Data::Serializer</a> will be called with the hash. You will need to ensure Data::Serializer is installed to use these options.</p>

<p>Otherwise, this must be a <a href="http://search.cpan.org/perldoc?Data%3A%3ASerializer" class="podlinkpod"
>Data::Serializer</a> object or another object that implements <i>serialize()</i> and <i>deserialize()</i>.</p>

<p>e.g.</p>

<pre>    # Serialize using raw Data::Dumper
    my $cache = CHI-&#62;new(serializer =&#62; &#39;Data::Dumper&#39;);

    # Serialize using Data::Dumper, compressed and (per Data::Serializer defaults) hex-encoded
    my $cache = CHI-&#62;new(serializer =&#62; { serializer =&#62; &#39;Data::Dumper&#39;, compress =&#62; 1 });

    # Serialize using custom object
    my $cache = CHI-&#62;new(serializer =&#62; My::Custom::Serializer-&#62;new())</pre>

<p>The default is to use raw Storable.</p>

<dt><a name="key_serializer_[STRING|HASHREF|OBJECT]"
>key_serializer [STRING|HASHREF|OBJECT]</a></dt>

<dd>
<p>An object to use for serializing keys that are references. See <a href="#serializer" class="podlinkpod"
>&#34;serializer&#34;</a> above for the different ways this can be passed in. The default is to use JSON in canonical mode (sorted hash keys).</p>

<dt><a name="on_get_error_[STRING|CODEREF]"
>on_get_error [STRING|CODEREF]</a></dt>

<dd>
<dt><a name="on_set_error_[STRING|CODEREF]"
>on_set_error [STRING|CODEREF]</a></dt>

<dd>
<p>How to handle runtime errors occurring during cache gets and cache sets, which may or may not be considered fatal in your application. Options are:</p>

<ul>
<li>log (the default) - log an error, or ignore if no logger is set - see <a href="#LOGGING" class="podlinkpod"
>&#34;LOGGING&#34;</a></li>

<li>ignore - do nothing</li>

<li>warn - call warn() with an appropriate message</li>

<li>die - call die() with an appropriate message</li>

<li><i>coderef</i> - call this code reference with three arguments: an appropriate message, the key, and the original raw error message</li>
</ul>
</dd>
</dl>

<p>Some drivers will take additional constructor options. For example, the File driver takes <code>root_dir</code> and <code>depth</code> options.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="INSTANCE_METHODS"
>INSTANCE METHODS</a></h1>

<p>The following methods can be called on any cache handle returned from CHI-&#62;new(). They are implemented in the <a href="http://search.cpan.org/perldoc?CHI%3A%3ADriver" class="podlinkpod"
>CHI::Driver</a> package.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Getting_and_setting"
>Getting and setting</a></h2>

<dl>
<dt><a name="get(_$key,_[option_=&#62;_value,_...]_)"
>get( $key, [option =&#62; value, ...] )</a></dt>

<dd>
<p>Returns the data associated with <i>$key</i>. If <i>$key</i> does not exist or has expired, returns undef. Expired items are not automatically removed and may be examined with <a href="#get_object" class="podlinkpod"
>&#34;get_object&#34;</a> or <a href="#get_expires_at" class="podlinkpod"
>&#34;get_expires_at&#34;</a>.</p>

<p><i>$key</i> may be followed by one or more name/value parameters:</p>

<dl>
<dt><a name="expire_if_[CODEREF]"
>expire_if [CODEREF]</a></dt>

<dd>
<p>If <i>$key</i> exists and has not expired, call code reference with the <a href="http://search.cpan.org/perldoc?CHI%3A%3ACacheObject" class="podlinkpod"
>CHI::CacheObject</a> as a single parameter. If code returns a true value, <code>get</code> returns undef as if the item were expired. For example, to treat the cache as expired if <i>$file</i> has changed since the value was computed:</p>

<pre>    $cache-&#62;get(&#39;foo&#39;, expire_if =&#62; sub { $_[0]-&#62;created_at &#60; (stat($file))[9] });</pre>

<dt><a name="busy_lock_[DURATION]"
>busy_lock [DURATION]</a></dt>

<dd>
<p>If the value has expired, set its expiration time to the current time plus the specified <a href="#DURATION_EXPRESSIONS" class="podlinkpod"
>duration</a> before returning undef. This is used to prevent multiple processes from recomputing the same expensive value simultaneously. The problem with this technique is that it doubles the number of writes performed - see <a href="#expires_variance" class="podlinkpod"
>&#34;expires_variance&#34;</a> for another technique.</p>
</dd>
</dl>

<dt><a name="set(_$key,_$data,_[$expires_in_|_&#34;now&#34;_|_&#34;never&#34;_|_options]_)"
>set( $key, $data, [$expires_in | &#34;now&#34; | &#34;never&#34; | options] )</a></dt>

<dd>
<p>Associates <i>$data</i> with <i>$key</i> in the cache, overwriting any existing entry. Returns <i>$data</i>.</p>

<p>The third argument to <code>set</code> is optional, and may be either a scalar or a hash reference. If it is a scalar, it may be the string &#34;now&#34;, the string &#34;never&#34;, or else a duration treated as an <i>expires_in</i> value described below. If it is a hash reference, it may contain one or more of the following options. Most of these options can be provided with defaults in the cache constructor.</p>

<dl>
<dt><a name="expires_in_[DURATION]"
>expires_in [DURATION]</a></dt>

<dd>
<p>Amount of time (in seconds) until this data expires.</p>

<dt><a name="expires_at_[INT]"
>expires_at [INT]</a></dt>

<dd>
<p>The epoch time at which the data expires.</p>

<dt><a name="expires_variance_[FLOAT]"
>expires_variance [FLOAT]</a></dt>

<dd>
<p>Controls the variable expiration feature, which allows items to expire a little earlier than the stated expiration time to help prevent cache miss stampedes.</p>

<p>Value is between 0.0 and 1.0, with 0.0 meaning that items expire exactly when specified (feature is disabled), and 1.0 meaning that items might expire anytime from now til the stated expiration time. The default is 0.0. A setting of 0.10 to 0.25 would introduce a small amount of variation without interfering too much with intended expiration times.</p>

<p>The probability of expiration increases as a function of how far along we are in the potential expiration window, with the probability being near 0 at the beginning of the window and approaching 1 at the end.</p>

<p>For example, in all of the following cases, an item might be considered expired any time between 15 and 20 minutes, with about a 20% chance at 16 minutes, a 40% chance at 17 minutes, and a 100% chance at 20 minutes.</p>

<pre>    my $cache = CHI-&#62;new ( ..., expires_variance =&#62; 0.25, ... );
    $cache-&#62;set($key, $value, &#39;20 min&#39;);
    $cache-&#62;set($key, $value, { expires_at =&#62; time() + 20*60 });

    my $cache = CHI-&#62;new ( ... );
    $cache-&#62;set($key, $value, { expires_in =&#62; &#39;20 min&#39;, expires_variance =&#62; 0.25 });</pre>

<p>CHI will make a new probabilistic choice every time it needs to know whether an item has expired (i.e. it does not save the results of its determination), so you can get situations like this:</p>

<pre>    my $value = $cache-&#62;get($key);     # returns undef (indicating expired)
    my $value = $cache-&#62;get($key);     # returns valid value this time!

    if ($cache-&#62;is_valid($key))        # returns undef (indicating expired)
    if ($cache-&#62;is_valid($key))        # returns true this time!</pre>

<p>Typical applications won&#39;t be affected by this, since the object is recomputed as soon as it is determined to be expired. But it&#39;s something to be aware of.</p>
</dd>
</dl>

<dt><a name="compute(_$key,_$set_options,_$code_)"
>compute( $key, $set_options, $code )</a></dt>

<dd>
<p>Combines the <code>get</code> and <code>set</code> operations in a single call. Attempts to get <i>$key</i>; if successful, returns the value. Otherwise, calls <i>$code</i> and uses the return value as the new value for <i>$key</i>, which is then returned. <i>$set_options</i> is a scalar or hash reference, used as the third argument to set.</p>

<pre>    $cache-&#62;compute($key, &#39;5min&#39;, sub {
        # compute and return value for $key here
    });</pre>

<p>This method will eventually support the ability to recompute a value in the background just before it actually expires, so that users are not impacted by recompute time.</p>

<p>Note: Prior to version 0.40, the last two arguments were in reverse order; both will be accepted for backward compatibility. We think the coderef looks better at the end.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Removing_and_expiring"
>Removing and expiring</a></h2>

<dl>
<dt><a name="remove(_$key_)"
>remove( $key )</a></dt>

<dd>
<p>Remove the data associated with the <i>$key</i> from the cache.</p>

<dt><a name="expire(_$key_)"
>expire( $key )</a></dt>

<dd>
<p>If <i>$key</i> exists, expire it by setting its expiration time into the past. Does not necessarily remove the data. Since this involves essentially setting the value again, <code>remove</code> may be more efficient for some drivers.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Inspecting_keys"
>Inspecting keys</a></h2>

<dl>
<dt><a name="is_valid(_$key_)"
>is_valid( $key )</a></dt>

<dd>
<p>Returns a boolean indicating whether <i>$key</i> exists in the cache and has not expired. Note: Expiration may be determined probabilistically if <a href="#expires_variance" class="podlinkpod"
>&#34;expires_variance&#34;</a> was used.</p>

<dt><a name="exists_and_is_expired(_$key_)"
>exists_and_is_expired( $key )</a></dt>

<dd>
<p>Returns a boolean indicating whether <i>$key</i> exists in the cache and has expired. Note: Expiration may be determined probabilistically if <a href="#expires_variance" class="podlinkpod"
>&#34;expires_variance&#34;</a> was used.</p>

<dt><a name="get_expires_at(_$key_)"
>get_expires_at( $key )</a></dt>

<dd>
<p>Returns the epoch time at which <i>$key</i> definitively expires. Returns undef if the key does not exist or it has no expiration time.</p>

<dt><a name="get_object(_$key_)"
>get_object( $key )</a></dt>

<dd>
<p>Returns a <a href="http://search.cpan.org/perldoc?CHI%3A%3ACacheObject" class="podlinkpod"
>CHI::CacheObject</a> object containing data about the entry associated with <i>$key</i>, or undef if no such key exists. The object will be returned even if the entry has expired, as long as it has not been removed.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Namespace_operations"
>Namespace operations</a></h2>

<dl>
<dt><a name="clear(_)"
>clear( )</a></dt>

<dd>
<p>Remove all entries from the namespace.</p>

<dt><a name="get_keys(_)"
>get_keys( )</a></dt>

<dd>
<p>Returns a list of keys in the namespace. This may or may not include expired keys, depending on the driver.</p>

<p>The keys may not look the same as they did when passed into <a href="#set" class="podlinkpod"
>&#34;set&#34;</a>; they may have been serialized, utf8 encoded, and/or digested (see <a href="#KEY_AND_VALUE_TRANSFORMATIONS" class="podlinkpod"
>&#34;KEY AND VALUE TRANSFORMATIONS&#34;</a>). However, they may still be passed back into <a href="#get" class="podlinkpod"
>&#34;get&#34;</a>, <a href="#set" class="podlinkpod"
>&#34;set&#34;</a>, etc. to access the same underlying objects. i.e. the following code is guaranteed to produce all key/value pairs from the cache:</p>

<pre>  map { ($_, $c-&#62;get($_)) } $c-&#62;get_keys()</pre>

<dt><a name="purge(_)"
>purge( )</a></dt>

<dd>
<p>Remove all entries that have expired from the namespace associated with this cache instance. Warning: May be very inefficient, depending on the number of keys and the driver.</p>

<dt><a name="get_namespaces(_)"
>get_namespaces( )</a></dt>

<dd>
<p>Returns a list of namespaces associated with the cache. This may or may not include empty namespaces, depending on the driver.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Multiple_key/value_operations"
>Multiple key/value operations</a></h2>

<p>The methods in this section process multiple keys and/or values at once. By default these are implemented with the obvious map operations, but some cache drivers (e.g. <a href="http://search.cpan.org/perldoc?Cache%3A%3AMemcached" class="podlinkpod"
>Cache::Memcached</a>) can override them with more efficient implementations.</p>

<dl>
<dt><a name="get_multi_arrayref(_$keys_)"
>get_multi_arrayref( $keys )</a></dt>

<dd>
<p>Get the keys in list reference <i>$keys</i>, and return a list reference of the same length with corresponding values or undefs.</p>

<dt><a name="get_multi_hashref(_$keys_)"
>get_multi_hashref( $keys )</a></dt>

<dd>
<p>Like <a href="#get_multi_arrayref" class="podlinkpod"
>&#34;get_multi_arrayref&#34;</a>, but returns a hash reference with each key in <i>$keys</i> mapping to its corresponding value or undef. Will only work with scalar keys.</p>

<dt><a name="set_multi(_$key_values,_$set_options_)"
>set_multi( $key_values, $set_options )</a></dt>

<dd>
<p>Set the multiple keys and values provided in hash reference <i>$key_values</i>. <i>$set_options</i> is a scalar or hash reference, used as the third argument to set. Will only work with scalar keys.</p>

<dt><a name="remove_multi(_$keys_)"
>remove_multi( $keys )</a></dt>

<dd>
<p>Removes the keys in list reference <i>$keys</i>.</p>

<dt><a name="dump_as_hash(_)"
>dump_as_hash( )</a></dt>

<dd>
<p>Returns a hash reference containing all the non-expired keys and values in the cache.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Property_accessors"
>Property accessors</a></h2>

<dl>
<dt><a name="driver_class(_)"
>driver_class( )</a></dt>

<dd>
<p>Returns the full name of the driver class. e.g.</p>

<pre>    CHI-&#62;new(driver=&#62;&#39;File&#39;)-&#62;driver_class
       =&#62; CHI::Driver::File
    CHI-&#62;new(driver_class=&#62;&#39;CHI::Driver::File&#39;)-&#62;driver_class
       =&#62; CHI::Driver::File
    CHI-&#62;new(driver_class=&#62;&#39;My::Driver::File&#39;)-&#62;driver_class
       =&#62; My::Driver::File</pre>

<p>You should use this rather than <code>ref()</code>. Due to some subclassing tricks CHI employs, the actual class of the object is neither guaranteed nor likely to be the driver class.</p>

<dt><a name="short_driver_name(_)"
>short_driver_name( )</a></dt>

<dd>
<p>Returns the name of the driver class, minus the CHI::Driver:: prefix, if any. e.g.</p>

<pre>    CHI-&#62;new(driver=&#62;&#39;File&#39;)-&#62;short_driver_name
       =&#62; File
    CHI-&#62;new(driver_class=&#62;&#39;CHI::Driver::File&#39;)-&#62;short_driver_name
       =&#62; File
    CHI-&#62;new(driver_class=&#62;&#39;My::Driver::File&#39;)-&#62;short_driver_name
       =&#62; My::Driver::File</pre>

<dt><a name="Standard_read-write_accessors"
>Standard read-write accessors</a></dt>

<dd>
<pre>    expires_in
    expires_at
    expires_variance
    label
    on_get_error
    on_set_error</pre>

<dt><a name="Standard_read-only_accessors"
>Standard read-only accessors</a></dt>

<dd>
<pre>    namespace
    serializer</pre>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Deprecated_methods"
>Deprecated methods</a></h2>

<p>The following methods are deprecated and will be removed in a later version:</p>

<pre>    is_empty</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DURATION_EXPRESSIONS"
>DURATION EXPRESSIONS</a></h1>

<p>Duration expressions, which appear in the <a href="#set" class="podlinkpod"
>&#34;set&#34;</a> command and various other parts of the API, are parsed by <a href="http://search.cpan.org/perldoc?Time%3A%3ADuration%3A%3AParse" class="podlinkpod"
>Time::Duration::Parse</a>. A duration is either a plain number, which is treated like a number of seconds, or a number and a string representing time units where the string is one of:</p>

<pre>    s second seconds sec secs
    m minute minutes min mins
    h hr hour hours
    d day days
    w week weeks
    M month months
    y year years</pre>

<p>e.g. the following are all valid duration expressions:</p>

<pre>    25
    3s
    5 seconds
    1 minute and ten seconds
    1 hour</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="KEY_AND_VALUE_TRANSFORMATIONS"
>KEY AND VALUE TRANSFORMATIONS</a></h1>

<p>CHI strives to accept arbitrary keys and values for caching regardless of the limitations of the underlying driver.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Key_transformations"
>Key transformations</a></h2>

<ul>
<li>Keys that are references are serialized - see <a href="#key_serializer" class="podlinkpod"
>&#34;key_serializer&#34;</a>.</li>

<li>Keys with wide (&#62;255) characters are utf8 encoded.</li>

<li>Keys exceeding the maximum length for the underlying driver are digested - see <a href="#max_key_length" class="podlinkpod"
>&#34;max_key_length&#34;</a> and <a href="#key_digester" class="podlinkpod"
>&#34;key_digester&#34;</a>.</li>

<li>For some drivers (e.g. <a href="http://search.cpan.org/perldoc?File" class="podlinkpod"
>CHI::Driver::File</a>), keys containing special characters or whitespace are escaped with URL-like escaping.</li>
</ul>

<p>Note: All transformations above with the exception of escaping are <i>one-way</i>, meaning that CHI does not attempt to undo them when returned from <a href="#get_keys" class="podlinkpod"
>&#34;get_keys&#34;</a>; and <i>idempotent</i>, meaning that applying them a second time has no effect. So when you call <a href="#get_keys" class="podlinkpod"
>&#34;get_keys&#34;</a>, the key you get may not be exactly what you passed in, but you&#39;ll be able to pass that key in to get the corresponding object.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Value_transformations"
>Value transformations</a></h2>

<ul>
<li>Values which are references are automatically serialized before storing, and deserialized after retrieving - see <a href="#serializer" class="podlinkpod"
>&#34;serializer&#34;</a>.</li>

<li>Values with their utf8 flag on are utf8 encoded before storing, and utf8 decoded after retrieving.</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SUBCACHES"
>SUBCACHES</a></h1>

<p>It is possible to a cache to have one or more <i>subcaches</i>. There are currently two types of subcaches: <i>L1</i> and <i>mirror</i>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="L1_cache"
>L1 cache</a></h2>

<p>An L1 (or &#34;level one&#34;) cache sits in front of the primary cache, usually to provide faster access for commonly accessed cache entries. For example, this places an in-process Memory cache in front of a Memcached cache:</p>

<pre>    my $cache = CHI-&#62;new(
        driver   =&#62; &#39;Memcached&#39;,
        servers  =&#62; [ &#34;10.0.0.15:11211&#34;, &#34;10.0.0.15:11212&#34; ],
        l1_cache =&#62; { driver =&#62; &#39;Memory&#39; }
    );</pre>

<p>On a <code>get</code>, the L1 cache is checked first - if a valid value exists, it is returned. Otherwise, the primary cache is checked - if a valid value exists, it is returned, and the value is placed in the L1 cache with the same expiration time. In this way, items fetched most frequently from the primary cache will tend to be in the L1 cache.</p>

<p><code>set</code> operations are distributed to both the primary and L1 cache.</p>

<p>You can access the L1 cache with the <code>l1_cache</code> method. For example, this clears the L1 cache but leaves the primary cache intact:</p>

<pre>    $cache-&#62;l1_cache-&#62;clear();</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Mirror_cache"
>Mirror cache</a></h2>

<p>A mirror cache is a write-only cache that, over time, mirrors the content of the primary cache. <code>set</code> operations are distributed to both the primary and mirror cache, but <code>get</code> operations go only to the primary cache.</p>

<p>Mirror caches are useful when you want to migrate from one cache to another. You can populate a mirror cache and switch over to it once it is sufficiently populated. For example, here we migrate from an old to a new cache directory:</p>

<pre>    my $cache = CHI-&#62;new(
        driver          =&#62; &#39;File&#39;,
        root_dir        =&#62; &#39;/old/cache/root&#39;,
        mirror_cache =&#62; { driver =&#62; &#39;File&#39;, root_dir =&#62; &#39;/new/cache/root&#39; },
    );</pre>

<p>We leave this running for a few hours (or as needed), then replace it with</p>

<pre>    my $cache = CHI-&#62;new(
        driver   =&#62; &#39;File&#39;,
        root_dir =&#62; &#39;/new/cache/root&#39;
    );</pre>

<p>You can access the mirror cache with the <code>mirror_cache</code> method. For example, to see how many keys have made it over to the mirror cache:</p>

<pre>    my @keys = $cache-&#62;mirror_cache-&#62;get_keys();</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Creating_subcaches"
>Creating subcaches</a></h2>

<p>As illustrated above, you create subcaches by passing the <code>l1_cache</code> and/or <code>mirror_cache</code> option to the CHI constructor. These options, in turn, should contain a hash of options to create the subcache with.</p>

<p>The cache containing the subcache is called the <i>parent cache</i>.</p>

<p>The following options are automatically inherited by the subcache from the parent cache, and may not be overriden:</p>

<pre>    expires_at
    expires_in
    expires_variance
    serializer</pre>

<p>(Reason: for efficiency, we want to create a single <a href="http://search.cpan.org/perldoc?CHI%3A%3ACacheObject" class="podlinkpod"
>cache object</a> and store it in both caches. The cache object contains expiration information and is dependent on the serializer. At some point we could conceivably add code that will use a single object or separate objects as necessary, and thus allow the above to be overriden.)</p>

<p>The following options are automatically inherited by the subcache from the parent cache, but may be overriden:</p>

<pre>    namespace
    on_get_error
    on_set_error</pre>

<p>All other options are initialized in the subcache as normal, irrespective of their values in the parent.</p>

<p>It is not currently possible to pass an existing cache in as a subcache.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Common_subcache_behaviors"
>Common subcache behaviors</a></h2>

<p>These behaviors hold regardless of the type of subcache.</p>

<p>The following methods are distributed to both the primary cache and subcache:</p>

<pre>    clear
    expire
    purge
    remove</pre>

<p>The following methods return information solely from the primary cache. However, you are free to call them explicitly on the subcache. (Trying to merge in subcache information automatically would require too much guessing about the caller&#39;s intent.)</p>

<pre>    get_keys
    get_namespaces
    get_object
    get_expires_at
    exists_and_is_expired
    is_valid
    dump_as_hash</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Multiple_subcaches"
>Multiple subcaches</a></h2>

<p>It is valid for a cache to have one of each kind of subcache, e.g. an L1 cache and a mirror cache.</p>

<p>A cache cannot have more than one of each kind of subcache, but a subcache can have its own subcaches, and so on. e.g.</p>

<pre>    my $cache = CHI-&#62;new(
        driver   =&#62; &#39;Memcached&#39;,
        servers  =&#62; [ &#34;10.0.0.15:11211&#34;, &#34;10.0.0.15:11212&#34; ],
        l1_cache =&#62; {
            driver     =&#62; &#39;File&#39;,
            root_dir   =&#62; &#39;/path/to/root&#39;,
            l1_cache   =&#62; { driver =&#62; &#39;Memory&#39; }
        }
    );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Methods_for_parent_caches"
>Methods for parent caches</a></h2>

<dl>
<dt><a name="has_subcaches(_)"
>has_subcaches( )</a></dt>

<dd>
<p>Returns a boolean indicating whether this cache has subcaches.</p>

<dt><a name="l1_cache(_)"
>l1_cache( )</a></dt>

<dd>
<p>Returns the L1 cache for this cache, if any. Can only be called if <i>has_subcaches</i> is true.</p>

<dt><a name="mirror_cache(_)"
>mirror_cache( )</a></dt>

<dd>
<p>Returns the mirror cache for this cache, if any. Can only be called if <i>has_subcaches</i> is true.</p>

<dt><a name="subcaches(_)"
>subcaches( )</a></dt>

<dd>
<p>Returns the subcaches for this cache, in arbitrary order. Can only be called if <i>has_subcaches</i> is true.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Methods_for_subcaches"
>Methods for subcaches</a></h2>

<dl>
<dt><a name="is_subcache(_)"
>is_subcache( )</a></dt>

<dd>
<p>Returns a boolean indicating whether this is a subcache.</p>

<dt><a name="subcache_type(_)"
>subcache_type( )</a></dt>

<dd>
<p>Returns the type of subcache as a string, e.g. &#39;l1_cache&#39; or &#39;mirror_cache&#39;. Can only be called if <i>is_subcache</i> is true.</p>

<dt><a name="parent_cache(_)"
>parent_cache( )</a></dt>

<dd>
<p>Returns the parent cache (weakened to prevent circular reference). Can only be called if <i>is_subcache</i> is true.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Developing_new_kinds_of_subcaches"
>Developing new kinds of subcaches</a></h2>

<p>At this time, subcache behavior is hardcoded into CHI::Driver, so there is no easy way to modify the behavior of existing subcache types or create new ones. We&#39;d like to make this more flexible eventually.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SIZE_AWARENESS"
>SIZE AWARENESS</a></h1>

<p>If <a href="#is_size_aware" class="podlinkpod"
>&#34;is_size_aware&#34;</a> or <a href="#max_size" class="podlinkpod"
>&#34;max_size&#34;</a> are passed to the constructor, the cache will be <i>size aware</i> - that is, it will keep track of its own size (in bytes) as items are added and removed. You can get a cache&#39;s size with <a href="#get_size" class="podlinkpod"
>&#34;get_size&#34;</a>.</p>

<p>Size aware caches generally keep track of their size in a separate meta-key, and have to do an extra store whenever the size changes (e.g. on each set and remove).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Maximum_size_and_discard_policies"
>Maximum size and discard policies</a></h2>

<p>If a cache&#39;s size rises above its <a href="#max_size" class="podlinkpod"
>&#34;max_size&#34;</a>, items are discarded until the cache size is sufficiently below the max size. (See <a href="#max_size_reduction_factor" class="podlinkpod"
>&#34;max_size_reduction_factor&#34;</a> for how to fine-tune this.)</p>

<p>The order in which items are discarded is controlled with <a href="#discard_policy" class="podlinkpod"
>&#34;discard_policy&#34;</a>. The default discard policy is &#39;arbitrary&#39;, which discards items in an arbitrary order. The available policies and default policy can differ with each driver, e.g. the <a href="http://search.cpan.org/perldoc?Memory" class="podlinkpod"
>CHI::Driver::Memory</a> driver provides and defaults to an &#39;LRU&#39; policy.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Appropriate_drivers"
>Appropriate drivers</a></h2>

<p>Size awareness was chiefly designed for, and works well with, the <a href="http://search.cpan.org/perldoc?Memory" class="podlinkpod"
>CHI::Driver::Memory</a> driver: one often needs to enforce a maximum size on a memory cache, and the overhead of tracking size in memory is negligible. However, the capability may be useful with other drivers.</p>

<p>Some drivers - for example, <a href="http://search.cpan.org/perldoc?FastMmap" class="podlinkpod"
>CHI::Driver::FastMmap</a> and <a href="http://search.cpan.org/perldoc?Memcached" class="podlinkpod"
>CHI::Driver::Memcached</a> - inherently keep track of their size and enforce a maximum size, and it makes no sense to turn on CHI&#39;s size awareness for these.</p>

<p>Also, for drivers that cannot atomically read and update a value - for example, <a href="http://search.cpan.org/perldoc?File" class="podlinkpod"
>CHI::Driver::File</a> - there is a race condition in the updating of size that can cause the size to grow inaccurate over time.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AVAILABILITY_OF_DRIVERS"
>AVAILABILITY OF DRIVERS</a></h1>

<p>The following drivers are currently available as part of this distribution:</p>

<ul>
<li><a href="http://search.cpan.org/perldoc?CHI%3A%3ADriver%3A%3AMemory" class="podlinkpod"
>CHI::Driver::Memory</a> - In-process memory based cache</li>

<li><a href="http://search.cpan.org/perldoc?CHI%3A%3ADriver%3A%3ARawMemory" class="podlinkpod"
>CHI::Driver::RawMemory</a> - In-process memory based cache that stores references directly instead of deep-copying</li>

<li><a href="http://search.cpan.org/perldoc?CHI%3A%3ADriver%3A%3AFile" class="podlinkpod"
>CHI::Driver::File</a> - File-based cache using one file per entry in a multi-level directory structure</li>

<li><a href="http://search.cpan.org/perldoc?CHI%3A%3ADriver%3A%3AFastMmap" class="podlinkpod"
>CHI::Driver::FastMmap</a> - Shared memory interprocess cache via mmap&#39;ed files</li>

<li><a href="http://search.cpan.org/perldoc?CHI%3A%3ADriver%3A%3ANull" class="podlinkpod"
>CHI::Driver::Null</a> - Dummy cache in which nothing is stored</li>

<li><a href="http://search.cpan.org/perldoc?CHI%3A%3ADriver%3A%3ACacheCache" class="podlinkpod"
>CHI::Driver::CacheCache</a> - CHI wrapper for Cache::Cache</li>
</ul>

<p>The following drivers are currently available as separate CPAN distributions:</p>

<ul>
<li><a href="http://search.cpan.org/perldoc?CHI%3A%3ADriver%3A%3AMemcached" class="podlinkpod"
>CHI::Driver::Memcached</a> - Distributed memory-based cache (works with <a href="http://search.cpan.org/perldoc?Cache%3A%3AMemcached" class="podlinkpod"
>Cache::Memcached</a>, <a href="http://search.cpan.org/perldoc?Cache%3A%3AMemcached%3A%3AFast" class="podlinkpod"
>Cache::Memcached::Fast</a>, and <a href="http://search.cpan.org/perldoc?Cache%3A%3AMemcached%3A%3Alibmemcached" class="podlinkpod"
>Cache::Memcached::libmemcached</a>)</li>

<li><a href="http://search.cpan.org/perldoc?CHI%3A%3ADriver%3A%3ADBI" class="podlinkpod"
>CHI::Driver::DBI</a> - Cache in any DBI-supported database</li>

<li><a href="http://search.cpan.org/perldoc?CHI%3A%3ADriver%3A%3ABerkeleyDB" class="podlinkpod"
>CHI::Driver::BerkeleyDB</a> - Cache in BerkeleyDB files</li>

<li><a href="http://search.cpan.org/perldoc?CHI%3A%3ADriver%3A%3ARedis" class="podlinkpod"
>CHI::Driver::Redis</a> - Cache in <a href="http://redis.io/" class="podlinkurl"
>Redis</a></li>
</ul>

<p>This list is likely incomplete. A complete set of drivers can be found on CPAN by searching for &#34;CHI::Driver&#34;.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PERFORMANCE_COMPARISON_OF_DRIVERS"
>PERFORMANCE COMPARISON OF DRIVERS</a></h1>

<p>See <a href="http://search.cpan.org/perldoc?CHI%3A%3ABenchmarks" class="podlinkpod"
>CHI::Benchmarks</a> for a comparison of read/write times of both CHI and non-CHI cache implementations.</p>

<p><code>etc/bench/bench.pl</code> in the <code>CHI</code> distribution contains a script to run these types of benchmarks on your own system.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DEVELOPING_NEW_DRIVERS"
>DEVELOPING NEW DRIVERS</a></h1>

<p>See <a href="http://search.cpan.org/perldoc?CHI%3A%3ADriver%3A%3ADevelopment" class="podlinkpod"
>CHI::Driver::Development</a> for information on developing new drivers.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LOGGING"
>LOGGING</a></h1>

<p><code>CHI</code> uses <a href="http://search.cpan.org/perldoc?Log%3A%3AAny" class="podlinkpod"
>Log::Any</a> for logging events. For example, a debug log message is sent for every cache get and set.</p>

<p>See <a href="http://search.cpan.org/perldoc?Log%3A%3AAny" class="podlinkpod"
>Log::Any</a> documentation for how to control where logs get sent, if anywhere.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="STATS"
>STATS</a></h1>

<p>CHI can record statistics, such as number of hits, misses and sets, on a per-namespace basis and log the results to your <a href="http://search.cpan.org/perldoc?Log%3A%3AAny" class="podlinkpod"
>Log::Any</a> logger. You can then use utilities included with this distribution to read stats back from the logs and report a summary. See <a href="http://search.cpan.org/perldoc?CHI%3A%3AStats" class="podlinkpod"
>CHI::Stats</a> for details.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="RELATION_TO_OTHER_MODULES"
>RELATION TO OTHER MODULES</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Cache::Cache"
>Cache::Cache</a></h2>

<p>CHI is intended as an evolution of DeWitt Clinton&#39;s <a href="http://search.cpan.org/perldoc?Cache%3A%3ACache" class="podlinkpod"
>Cache::Cache</a> package. It starts with the same basic API (which has proven durable over time) but addresses some implementation shortcomings that cannot be fixed in Cache::Cache due to backward compatibility concerns. In particular:</p>

<dl>
<dt><a name="Performance"
>Performance</a></dt>

<dd>
<p>Some of Cache::Cache&#39;s subclasses (e.g. <a href="http://search.cpan.org/perldoc?Cache%3A%3AFileCache" class="podlinkpod"
>Cache::FileCache</a>) have been justifiably criticized as inefficient. CHI has been designed from the ground up with performance in mind, both in terms of general overhead and in the built-in driver classes. Method calls are kept to a minimum, data is only serialized when necessary, and metadata such as expiration time is stored in packed binary format alongside the data.</p>

<p>As an example, using Rob Mueller&#39;s cacheperl benchmarks, CHI&#39;s file driver runs 3 to 4 times faster than Cache::FileCache.</p>

<dt><a name="Ease_of_subclassing"
>Ease of subclassing</a></dt>

<dd>
<p>New Cache::Cache subclasses can be tedious to create, due to a lack of code refactoring, the use of non-OO package subroutines, and the separation of &#34;cache&#34; and &#34;backend&#34; classes. With CHI, the goal is to make the creation of new drivers as easy as possible, roughly the same as writing a TIE interface to your data store. Concerns like serialization and expiration options are handled by the driver base class so that individual drivers don&#39;t have to worry about them.</p>

<dt><a name="Increased_compatibility_with_cache_implementations"
>Increased compatibility with cache implementations</a></dt>

<dd>
<p>Probably because of the reasons above, Cache::Cache subclasses were never created for some of the most popular caches available on CPAN, e.g. <a href="http://search.cpan.org/perldoc?Cache%3A%3AFastMmap" class="podlinkpod"
>Cache::FastMmap</a> and <a href="http://search.cpan.org/perldoc?Cache%3A%3AMemcached" class="podlinkpod"
>Cache::Memcached</a>. CHI&#39;s goal is to be able to support these and other caches with a minimum performance overhead and minimum of glue code required.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Cache"
>Cache</a></h2>

<p>The <a href="http://search.cpan.org/perldoc?Cache" class="podlinkpod"
>Cache</a> distribution is another redesign and implementation of Cache, created by Chris Leishman in 2003. Like CHI, it improves performance and reduces the barrier to implementing new cache drivers. It breaks with the Cache::Cache interface in a few ways that I considered non-negotiable - for example, get/set do not serialize data, and namespaces are an optional feature that drivers may decide not to implement.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Cache::Memcached,_Cache::FastMmap,_etc."
>Cache::Memcached, Cache::FastMmap, etc.</a></h2>

<p>CPAN sports a variety of full-featured standalone cache modules representing particular backends. CHI does not reinvent these but simply wraps them with an appropriate driver. For example, CHI::Driver::Memcached and CHI::Driver::FastMmap are thin layers around Cache::Memcached and Cache::FastMmap.</p>

<p>Of course, because these modules already work on their own, there will be some overlap. Cache::FastMmap, for example, already has code to serialize data and handle expiration times. Here&#39;s how CHI resolves these overlaps.</p>

<dl>
<dt><a name="Serialization"
>Serialization</a></dt>

<dd>
<p>CHI handles its own serialization, passing a flat binary string to the underlying cache backend.</p>

<dt><a name="Expiration"
>Expiration</a></dt>

<dd>
<p>CHI packs expiration times (as well as other metadata) inside the binary string passed to the underlying cache backend. The backend is unaware of these values; from its point of view the item has no expiration time. Among other things, this means that you can use CHI to examine expired items (e.g. with $cache-&#62;get_object) even if this is not supported natively by the backend.</p>

<p>At some point CHI will provide the option of explicitly notifying the backend of the expiration time as well. This might allow the backend to do better storage management, etc., but would prevent CHI from examining expired items.</p>
</dd>
</dl>

<p>Naturally, using CHI&#39;s FastMmap or Memcached driver will never be as time or storage efficient as simply using Cache::FastMmap or Cache::Memcached. In terms of performance, we&#39;ve attempted to make the overhead as small as possible, on the order of 5% per get or set (benchmarks coming soon). In terms of storage size, CHI adds about 16 bytes of metadata overhead to each item. How much this matters obviously depends on the typical size of items in your cache.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SUPPORT_AND_DOCUMENTATION"
>SUPPORT AND DOCUMENTATION</a></h1>

<p>Questions and feedback are welcome, and should be directed to the perl-cache mailing list:</p>

<pre>    http://groups.google.com/group/perl-cache-discuss</pre>

<p>Bugs and feature requests will be tracked at RT:</p>

<pre>    http://rt.cpan.org/NoAuth/Bugs.html?Dist=CHI
    bug-chi@rt.cpan.org</pre>

<p>The latest source code can be browsed and fetched at:</p>

<pre>    http://github.com/jonswar/perl-chi/tree/master
    git clone git://github.com/jonswar/perl-chi.git</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TODO"
>TODO</a></h1>

<ul>
<li>Perform cache benchmarks comparing both CHI and non-CHI cache implementations</li>

<li>Release BerkeleyDB drivers as separate CPAN distributions</li>

<li>Add docs comparing various strategies for reducing miss stampedes and cost of recomputes</li>

<li>Add expires_next syntax (e.g. expires_next =&#62; &#39;hour&#39;)</li>

<li>Support automatic serialization and escaping of keys</li>

<li>Create XS versions of main functions in Driver.pm (e.g. get, set)</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ACKNOWLEDGMENTS"
>ACKNOWLEDGMENTS</a></h1>

<p>Thanks to Dewitt Clinton for the original Cache::Cache, to Rob Mueller for the Perl cache benchmarks, and to Perrin Harkins for the discussions that got this going.</p>

<p>CHI was originally designed and developed for the Digital Media group of the Hearst Corporation, a diversified media company based in New York City. Many thanks to Hearst management for agreeing to this open source release.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="http://search.cpan.org/perldoc?Cache%3A%3ACache" class="podlinkpod"
>Cache::Cache</a></p>

<!-- end doc -->

</body></html>
