TO DO

* Migrate to git (better for working on planes :))
  * Recreate git just from trunk (no branches/tags)
. Allow suppression of renames when creating new item
. Separate Memcached into its own CPAN distribution
  . Release
. Offer several serialization options via Data::Serializer - in 0.08
* Create Cache::Bench from Rob's cacheperl; run full suite of benchmarks comparing CHI and non-CHI caches
* Fix Mason $m->cache() to memoize cache object, at least with no arguments - taking care to react to changes in default_cache_options
* BerkeleyDB driver (w/separate file per namespace, must handle locking) (Perrin doing this?)
* DBI driver (at least mysql) (Perrin doing this?)
* Convert to Log::Any
* expires_next => ['hour', 'day']
* compare strategies for reducing miss stampedes in docs
* Test:
  * bad driver
  * default settings for $cache object: expires_at, expires_in
  * dir_create_mode and file_create_mode in File driver (test only under Unix)
* Null driver

POSSIBLY

* Do auto-key-digesting for too-long keys - eliminates max key length - can work regardless of driver, but each driver can have its own default max key length, and will have to store key inside metadata in just this case - is it worth it?
* Add cache signature, encapsulating CHI's metadata version and options to the driver, as a second differentiator alongside namespace
* Create faster get_object variant that does not support value - e.g. so file cache can read just metadata - then use this variant for get_expires_at, etc.
* Handle unicode chars in escape_for_filename by utf8 encoding when needed (but how to know when unescaping...) - is it worth it? Did Cache::FileCache handle unicode keys?
* support key escaping for any drivers that need it, e.g. memcached (via parameter, default on)
* background compute
* implement read-only and write-only caches (useful for multilevel caches)

QUESTIONS

* Which drivers (memory, file, fastmmap, memcached) should we include with CHI, and which should we release separately?
* Is there a value to separating out the constructor to CHI->new, and putting everything else in CHI::Driver, other than that it is vaguely DBI-like?
* What should set() return? The value? Success flag? Cache::Cache doesn't seem to specify.
* Should we auto-remove items after a miss, like Cache::Cache? Or is this silly b/c it will probably be followed with a set?
* Should namespace default to caller package?
* What happens if a reference is passed as a key? Stringify reference, or reject, or serialize automatically to a key?
* Should get_namespace() always/sometimes/never report empty namespaces - i.e. namespaces that have been created but not populated, or namespaces that have been cleared?
* Should multilevel driver be renamed - potential confusion with get_multi_*, set_multi, etc.?
